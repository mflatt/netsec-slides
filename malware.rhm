#lang rhombus/static/and_meta

import:
  rhombus/runtime_path
  pict/radial
  "common.rhm" open
  "delays.rhm"!network as delays

runtime_path.def file_png: "images/file.png"
runtime_path.def thompson_ritchie_jpg: "images/thompson-ritchie.jpg"
runtime_path.def windows_png: "images/windows.png"
runtime_path.def linux_png: "images/linux.png"
runtime_path.def macos_png: "images/macos.png"
runtime_path.def c_png: "images/c.png"
runtime_path.def javascript_png: "images/javascript.png"

runtime_path.def cd_png: "images/cd.png"

def all_scale = 0.2

def file = bitmap(file_png).scale(all_scale)
def windows_logo = bitmap(windows_png).scale(all_scale)
def linux = bitmap(linux_png).scale(all_scale)
def macos = bitmap(macos_png).scale(0.8).scale(all_scale)
def c = bitmap(c_png).scale(0.5).scale(all_scale)
def javascript = bitmap(javascript_png).scale(0.35).scale(all_scale)
def cd = bitmap(cd_png).scale(all_scale)

fun gear(~fill: color, ~rotate: r) :~ Pict:
  fun mk(color) :~ Pict:
    radial.gear(~width: 96,
                ~fill: color,
                ~arms: 6,
                ~rotate: r)
  overlay.top_left(mk(Color(color).scale(0.8)).pad(~left: 5, ~top: 5),
                   mk(Color(color)))
  

def executable = gear(~fill: "lightgray",
                      ~rotate: 1/8*math.pi)
def compiler = gear(~fill: "cadetblue",
                    ~rotate: -1/8*math.pi)
def compiler2 = gear(~fill: "plum",
                     ~rotate: -1/8*math.pi)
def compiler3 = gear(~fill: "pink",
                     ~rotate: -1/8*math.pi)

def bug = gear(~fill: "firebrick", ~rotate: 0)
def bug_src = rectangle(~width: 64, ~fill: "firebrick")
def meta_bug = beside(bug, radial.arrow(~fill: "blue"))
def fixpoint_bug = connect(~on: meta_bug,
                           Find(bug, ~dhoriz: 0.25, ~dvert: -0.25),
                           Find.top(bug),
                           ~start_angle: 1/4 * math.pi,
                           ~start_pull: 2,
                           ~end_angle: -1/2 * math.pi,
                           ~end_pull: 2,
                           ~line_width: 8,
                           ~line: "blue",
                           ~style: #'arrow,
                           ~arrow_size: 32)

def fallout_color = "pink"

fun label(p, l :~ Pict) :~ Pict:
  stack(~sep: 4, p, l.scale(0.8))

fun add_bug(executable, bug :~ Pict, on = #true) :~ Pict:
  if on
  | overlay.top_right(executable,
                      bug.scale(0.33).pad(~right: 10, ~top: 20))
  | executable

fun trojan_horse(options :~ OptMap) :~ Pict:
  let n1 = options[#'src] || 0
  let n2 = options[#'compiler_src] || 0
  let n3 = options[#'compiler2] || 0
  let prog_file = file.launder()
  let gcc_src2 = file.launder()
  let labeled_gcc_src1 = label(file, @tt{gcc-v13.c})
  let fixpoint_bug_at_compiler2 = fixpoint_bug.launder()
  let etc = @tt{...}
  let sep = 64
  let labeled_compiler3:
    label(add_bug(compiler3, fixpoint_bug), @tt{gcc-v11})
  let prev_prev:
    stack(~sep: sep,
          etc,
          labeled_compiler3)
  let labeled_compiler2:
    label(add_bug(compiler2, if options[#'compiler2_meta_bug] | fixpoint_bug_at_compiler2 | meta_bug), @tt{gcc-v12})
  let prev:
    beside.bottom(~sep: sep,
                  label(gcc_src2, @tt{gcc-v12.c}).ghost(!options[#'compiler3]),
                  prev_prev.refocus(labeled_compiler3).ghost(!options[#'compiler3]),
                  labeled_compiler2)
  let p:
    beside.bottom(~sep: sep * n1,
                  label(add_bug(prog_file, bug_src.translate(-48, 32),
                                options[#'bug_src] && !options[#'compiler_bug]), @tt{prog.c})
                    .scale(n1),
                  stack(~sep: sep * n2,
                        stack(~sep: sep,
                              add_bug(labeled_gcc_src1, bug_src.translate(-96, 32),
                                      options[#'compiler_bug_src] && ((options[#'compiler2] || 0) .= 0)),
                              prev.refocus(labeled_compiler2).pad(~bottom: 32).scale(n3)).scale(n2),
                        label(add_bug(compiler,
                                      if options[#'compiler2_meta_bug] | fixpoint_bug | meta_bug,
                                      options[#'compiler_bug]), @tt{gcc-v13}).pad(~top: -32))
                    .ghost(!options[#'compiler]).scale(n1),
                  label(add_bug(executable, bug, options[#'bug]), @tt{a.out}))
  fun conn(p, f, t, ~vert = #false):
    connect(~on: p,
            if vert | Find.bottom(f, ~dy: 10) | Find.right(f, ~dx: 10),
            if vert | Find.top(t, ~dy: -10) | Find.left(t, ~dx: -10),
            ~line: "purple",
            ~style: #'arrow,
            ~line_width: 3)
  let p:
    if n1 > 0.9
    | conn(p, prog_file, if options[#'compiler] | compiler | executable)
    | p
  let p = if options[#'compiler] | conn(p, compiler, executable) | p
  let p:
    cond
    | (options[#'compiler2] || 0) > 0:
        let p = conn(p, labeled_compiler2, compiler, ~vert: #true)
        let p = conn(p, labeled_gcc_src1, compiler2, ~vert: #true)
        cond
        | (options[#'compiler3] || 0) > 0:
            let p = conn(p, compiler3, compiler2)
            let p = conn(p, gcc_src2, compiler3)
            let p = conn(p, etc, compiler3, ~vert: #true)
            p
        | ~else:
            p
    | (options[#'compiler_src] || 0) > 0.5:
        let p = conn(p, labeled_gcc_src1, compiler, ~vert: #true)
        p
    | ~else:
        p
  let p:
    if options[#'trust]
    | balloon.pin(~on: p,
                  ~at: Find.right(executable),
                  ~spike: #'w,
                  @para{Trust this executable?})
    | p
  let p:
    if options[#'maybe_bug] && n1 .= 0
    | balloon.pin(~on: p,
                  ~at: Find.right(executable),
                  ~spike: #'nw,
                  block:
                    let p: @para{Maybe it has bugs...}
                    if options[#'maybe_malware]
                    | stack(~sep: slide.gap,
                            ~horiz: #'left,
                            p,
                            lines(@para{Maybe it even intentionally},
                                  @para{behaves against a user's wishes}))
                    | p)
    | p
  let p:
    if options[#'inspect_source]
    | balloon.pin(~on: p,
                  ~at: Find.left(bug_src),
                  ~spike: #'e,
                  @para{Look for bad behavior in source})
    | p
  let p:
    if options[#'inspect_compiler] && n2 .= 0
    | balloon.pin(~on: p,
                  ~at: Find.top(compiler),
                  ~spike: #'s,
                  @para{Problem could be in the compiler!})
    | p
  let p:
    if options[#'inspect_meta]
    | balloon.pin(~on: p,
                  ~at: Find.top(fixpoint_bug_at_compiler2),
                  ~spike: #'nw,
                  ~dx: -64,
                  block:
                    let p = @para{Behavior could even reinstall itself}
                    if options[#'virus]
                    | stack.left(~sep: slide.gap,
                                 p,
                                 lines(@para{Could be considered a @defterm{virus} or a},
                                       @para{@defterm{trojan horse}}))
                    | p)
    | p
  let p :~ Pict:
    if options[#'provenance]
    | balloon.pin(~on: p,
                  ~at: Find.top(etc),
                  ~spike: #'s,
                  ~sprout: 0.8,
                  lines(@para{To be sure, you need complete},
                        @para{provenance for the compiler}))
    | p
  let p:
    if options[#'unix]
    | beside(
        ~vert: #'top,
        p.pad(~right: -100),
        beside(~sep: 32,
               bitmap(thompson_ritchie_jpg).scale(0.5),
               lines(@para{Context of Thompson's},
                     @para{speech:},
                     @para{new laws to clarify that},
                     @para{virtual spaces are},
                     @para{private property}))
          .scale(0.75)
      ).refocus(p)
    | p
  p

fun trojan_horse_slide(options :~ OptMap,
                       ~animate: key = #false,
                       ~archival: archival = #true) :~ OptMap:
  fun keep(p): if archival | p | nonarchival(p)
  slide(~title: stack(titlet("Reflections on Trusting Trust"),
                      titlet("Ken Thompson, 1983 Turing Award Lecture").scale(0.6)),
        ~name: "Reflections on Trusting Trust",
        keep(if key
             | animate(fun (n): trojan_horse(options ++ { key: n }))
             | trojan_horse(options)))
  options

let options = trojan_horse_slide({}, ~archival: #false)
let aside_options = trojan_horse_slide(options ++ { #'trust })
let options = options ++ { #'bug }
let aside_options = trojan_horse_slide(options ++ { #'maybe_bug })
let aside_options = trojan_horse_slide(aside_options ++ { #'maybe_malware }, ~animate: #'src)
let options = trojan_horse_slide(options ++ { #'src: 1 })
let options = options ++ { #'bug_src }
let aside_options = trojan_horse_slide(options ++ { #'inspect_source })
let options = trojan_horse_slide(options ++ { #'compiler })
let options = options ++ { #'compiler_bug }
let aside_options = trojan_horse_slide(options ++ { #'inspect_compiler }, ~animate: #'compiler_src)
let options = trojan_horse_slide(options ++ { #'compiler_src: 1 })
let options = trojan_horse_slide(options ++ { #'compiler_bug_src }, ~animate: #'compiler2)
let options = trojan_horse_slide(options ++ { #'compiler2: 1 })
let options = options ++ { #'compiler2_meta_bug }
let aside_options = trojan_horse_slide(options ++ { #'inspect_meta })
let aside_options = trojan_horse_slide(aside_options ++ { #'virus })
let options = trojan_horse_slide(options ++ { #'compiler3: 1 })
let aside_options = trojan_horse_slide(options ++ { #'provenance })
let options = trojan_horse_slide(options ++ { #'unix })

module morris_worm ~lang rhombus/static/and_meta:
  import:
    rhombus/runtime_path
    "common.rhm" open
    "delays.rhm"!network as delays

  export:
    morris_worm_pict
    worm

  runtime_path.def worm_png: "images/worm.png"
  def worm = bitmap(worm_png).scale(0.2)

  def server = delays.server.scale(0.5).launder()
  def servers :~ List.of(Pict):
    for List (i: 0..8):
      server.launder()

  fun connect_all(p, active, [[from, to], ...], width) :~ Pict:  
    let lw = 3
    for values(p = p) (from: [from, ...],
                       to: [to, ...]):
      let (color, lw):
        if active == from || active == to
        | values("red", lw * width)
        | values("black", lw)
      let from = servers[from]
      let to = servers[to]
      let (fx, fy) = Find(from).in(p)
      let (tx, ty) = Find(to).in(p)
      cond
      | fx .< tx:
          connect(~on: p,
                  Find.right(from),
                  Find.left(to),
                  ~line: color,
                  ~line_width: lw)
      | ~else:
          connect(~on: p,
                  Find.bottom(from),
                  Find.top(to),
                  ~line: color,
                  ~line_width: lw)

  fun morris_worm_pict(options :~ OptMap, step, infected :~ List,
                       ~width: width = 1) :~ Pict:
    let p:
      beside(~sep: 96,
             servers[0],
             stack(~sep: 64, servers[1], servers[2], servers[3]),
             stack(~sep: 48, servers[4], servers[5]),
             stack(~sep: 32, blank(), servers[6], servers[7]))
    let (p :~ Pict, _):
      for values(p = p, seen :~ Map = {}) (i: infected):
        let n = seen.get(i, 0)
        values(pin(~on: p,
                   ~at: Find.top(servers[i], ~dx: -worm.width/2, ~dy: (n+1) * -worm.height/2),
                   worm),
               seen ++ { i: n + 1 })
    let p:
      connect_all(p,
                  step,
                  [[0, 1], [0, 2], [0, 3],
                   [1, 4], [2, 4], [2, 5], [3, 5], [2, 3],
                   [4, 6], [4, 7], [5, 7]],
                  width)
    let p:
      if options[#'reinfect]
      | balloon.pin(~on: p,
                    ~at: Find.left(servers[0]),
                    ~spike: #'e,
                    @para{Reinfect with probability @frac(@t{1}, @t{7})})
      | p
    let p:
      if options[#'too_many]
      | balloon.pin(~on: p,
                    ~at: Find.top(servers[4]),
                    ~spike: #'sw,
                    ~dx: -64,
                    lines(@para{Number of worms on each machine},
                          @para{quickly got out of hand!}))
      | p
    p
import self!morris_worm open

fun morris_worm_slide(options :~ OptMap, step, infected :~ List,
                      ~width: width = 1) :~ OptMap:
  let p = morris_worm_pict(options, step, infected,
                           ~width: width)
  let p:
    if options[#'felony]
    | beside.bottom(~sep: 32,
                    p,
                    @balloon.note(~fill: fallout_color,
                                  lines(@para{Fallout: felony for the},
                                        @para{worm's author})))
        .refocus(p)
    | p    
  slide(~title: stack(titlet("Early Internet Worm"),
                      titlet("Robert T. Morris, 1988").scale(0.6)),
        ~name: "Morris Worm",
        slide.align(
          @para{Grad student at Cornell tests internet security:},
          slide.left(
            ~sep: 16,
            @item{exploit debug-mode hole in @tt{sendmail}},
            @item{exploit buffer-overflow bug in @tt{fingerd}},
            @item{exploit weak passwords}
          ),
          @para{with botnet-like propagation, making it a @defterm{worm}}.ghost(!options[#'def_worm]),
        ),
        blank(),
        p.ghost(!options[#'worms]))
  options

let options = morris_worm_slide({}, #false, [0])
let options = morris_worm_slide(options ++ { #'def_worm }, #false, [0])
let options = morris_worm_slide(options ++ { #'worms }, #false, [0])
let options = morris_worm_slide(options, 0, [0])
let options = morris_worm_slide(options, #false, [0, 1, 2, 3])
let options = morris_worm_slide(options, 1, [0, 1, 2, 3])
let aside_options = morris_worm_slide(options ++ { #'reinfect }, 1, [0, 1, 2, 3])
let options = morris_worm_slide(options, #false, [0, 1, 2, 3, 4])
let options = morris_worm_slide(options, 2, [0, 1, 2, 3, 4])
let options = morris_worm_slide(options, #false, [0, 1, 2, 3, 4, 4, 5])
let options = morris_worm_slide(options, 3, [0, 1, 2, 3, 4, 4, 5])
let options = morris_worm_slide(options, #false, [0, 1, 2, 2, 3, 4, 4, 5])
let options = morris_worm_slide(options, 4, [0, 1, 2, 2, 3, 4, 4, 5])
let options = morris_worm_slide(options, 4, [0, 1, 2, 2, 3, 4, 4, 5], ~width: 2)
let options = morris_worm_slide(options, #false, [0, 1, 2, 2, 2, 3, 4, 4, 5, 6, 7])
let options = morris_worm_slide(options ++ { #'too_many }, #false, [0, 1, 2, 2, 2, 3, 4, 4, 5, 6, 7])
let options = morris_worm_slide(options ++ { #'felony }, #false, [0, 1, 2, 2, 2, 3, 4, 4, 5, 6, 7])

fun sony_bmg_slide(options :~ OptMap) :~ OptMap:
  let p:    
    beside(~sep: 32,
           cd,
           @bold{+},
           overlay.top(delays.laptop, windows_logo.pad(~top: 20)),
           @bold{=},
           label(file, @tt{song.mp3}))
  let p:
    if options[#'formats]
    | balloon.pin(~on: p,
                  ~at: Find.bottom(cd),
                  ~spike: #'n,
                  ~dy: -64,
                  lines(@para{Some CDs have music,},
                        @para{others have games,},
                        @para{...}))
    | p
  let p:
    if options[#'autorun]
    | balloon.pin(~on: p,
                  ~at: Find.bottom(cd),
                  ~spike: #'n,
                  ~dy: -64,
                  lines(@para{Windows runs @tt{autorun.exe}},
                        @para{from CD to let it pick behavior}))
    | p
  let thwart = @para{thwart uninstall attempts}.colorize("firebrick")
  let thwart:
    if options[#'rootkit_sys]
    | balloon.pin(~on: thwart,
                  ~at: Find.bottom(thwart),
                  ~spike: #'n,
                  ~fill: "lightgreen",
                  lines(@para{Hide file names that start with @tt{$sys$}},
                        if options[#'others]
                        | @para{--- which was great for @italic{other} attackers}
                        | nothing))
    | thwart
  let patch: @para{patch the operating system}.colorize("firebrick")
  let patch:
    cond
    | options[#'rootkit_hide]:
        balloon.pin(~on: patch,
                    ~at: Find.bottom(patch),
                    ~spike: #'n,
                    @para{Also, to @thwart})
    | options[#'rootkit]:
        balloon.pin(~on: patch,
                    ~at: Find.bottom(patch),
                    ~spike: #'n,
                    @para{A trojan horse that acts like a @defterm{rootkit}})
    | ~else:
        patch
  let p:
    if options[#'lawsuit]
    | pin(~on: p,
          ~at: Find.bottom_right(p, ~dy: 200),
          balloon.note(~fill: fallout_color,
                       lines(~horiz: #'right,
                             @para{Fallout: many lawsuits},
                             @para{against Sony})))
    | p
  slide(~title: stack(titlet("Defense Gone Wrong"),
                      titlet("Sony BMG, 2005").scale(0.6)),
        ~name: "Sony BMG",
        @para{Sony's problem: Easy to copy digital music files from a CD on Windows},
        blank(32),
        p,
        blank(32),
        balloon.note(
          lines(@para{Sony's idea: include @tt{autorun.exe} on music CDs, and},
                @para{make it @patch to disable song copying}),
          ~fill: "lightblue"
        ).ghost(!options[#'rootkit_autorun]),
        blank(32))
  options

let options = sony_bmg_slide({})
let aside_options = sony_bmg_slide(options ++ { #'formats })
let aside_options = sony_bmg_slide(options ++ { #'autorun })
let rootkit_options = options ++ { #'rootkit_autorun }
let options = sony_bmg_slide(rootkit_options)
let aside_options = sony_bmg_slide(rootkit_options ++ { #'rootkit })
let options = sony_bmg_slide(options ++ { #'rootkit_hide })
let options = sony_bmg_slide(options ++ { #'rootkit_sys })
let options = sony_bmg_slide(options ++ { #'others })
let options = sony_bmg_slide(options ++ { #'lawsuit })

fun delay(p :~ Pict, n):
  if n == 0
  | p
  | switch(nonarchival(p.ghost()), delay(p, n-1))

fun timeline(step :~ Pict, ...):
  let a_dot:
    circle(~size: 16, ~fill: "gray", ~line: "black")
  let [dot, ...]:
    for List (s: [step, ...]):
      a_dot.launder()
  let [time, ...]: List.iota([step, ...].length())
  let pre_dot = a_dot.launder().ghost()
  let post_dot = a_dot.launder().ghost()
  let p:
    stack.left(~sep: 2 * slide.gap,
               pre_dot,
               beside(~vert: #'topline,
                      ~sep: 16,
                      dot,
                      delay(step, time)),
               ...,
               post_dot)
  for values(p = p) (sf: [pre_dot, dot, ...],
                     st: [dot, ..., post_dot]):
    connect(~on: p,
            Find.bottom(sf),
            Find.top(st),
            ~line_width: 3)

slide(~title: stack(titlet("Spy Games Gone Wrong"),
                    titlet("WannaCry, 2017").scale(0.6)),
      ~name: "WannaCry",
      slide.alts(
        timeline(@para{Early 2010s: Windows network vulnerability},
                 stack(~horiz: #'right,
                       @para{Mid 2010s: NSA creates @bold{EternalBlue} exploit},
                       @para{does not alert Microsoft}.colorize("blue").scale(0.8)),
                 @para{sometime before March 2017: EternalBlue is stolen},
                 @para{March 2017: NSA alerts Microsoft, bug is patched},
                 @para{April 2017: @bold{WannaCry} worm attacks unpatched installations}),
        slide.align(
          @para{WannaCry operation:},
          @item{encrypt many files to new @tt{.wncry} files},
          @item{delete unencrypted originals},
          @item{get user to pay ransom in Bitcoin},
          block:
            let url = @tt{iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com}
            let p = @item{check @url}
            switch(p.ghost(),
                   p,
                   balloon.pin(~on: p,
                               ~at: Find.bottom(url),
                               ~spike: #'n,
                               ~dy: -96,
                               lines(@para{Security researcher registered this domain name,},
                                     @para{accidentally stopping the worm's spread!}))),
          @item{infect other machines using EternalBlue exploit}
        )
      ))

fun example(l, ...):
  slide.right(para(l, ...).colorize("blue").scale(0.8))

slide(~title: "Malware",
      @para{All of those examples are @defterm{malware}: software that intentionally behaves against a user's wishes},
      slide.next,
      blank(32),
      slide.alts(
        [slide.align(
           @para{Who}.colorize("blue").pad(~left: -32),
           @item{@bold{Script kiddies} --- use published malware},
           @item{@bold{Skilled criminals} --- mostly modify existing malware},
           @item{@bold{State-sponsored groups} --- develop new malware}
         )],
        [slide.align(
           @para{Why}.colorize("blue").pad(~left: -32),
           @item{Information and identity theft},
           @item{Encrypt/steal data for ransom},
           @item{Inject/falsify data},
           @item{Break things controlled by software},
           @item{Steal resources (e.g., for spamming)}
         )]
      ))

slide(~title: "Kinds of Malware Delivery",
      slide.align(
        @para{@(add_bug(compiler, bug).scale(0.25)) @defterm{Trojan horse} --- actual behavior different than advertised},
        @example{example: Sony copy protection},
        blank(),
        @para{@fixpoint_bug.scale(0.25) @defterm{Virus} --- uses a host program to run and propagate itself},
        example(beside.topline(@t{examples: },
                               lines(@para{VisualBasic scripts in a Word document,},
                                     @para{malformed PDF that injects code into viewer}))),
        blank(),
        @para{@worm.scale(0.5) @defterm{Worm} --- creates own processes to replicate itself},
        @example{examples: Mirai, WannaCry}
      ))

slide(~title: "Malware Payload",
      slide.align(
        @para{@defterm{Payload} is the part of malware that performs the bad action},
        @example{as delivered by a virus, worm, or trojan horse},
        blank(),
        @para{Example payloads:},
        @item{copying data},
        @item{deleting files},
        @item{encryping files},
        @item{creating backdoor access for future commands},
        slide.next,
        blank(),
        @example{A rootkit is normally considered a payload}
      ))

fun layer(p, fill, width, ~height: height = 1.2) :~ Pict:
  rectangle(~around: p,
            ~height: height * linux.height,
            ~width: width,
            ~line: Color(fill).scale(0.5),
            ~fill: fill)

def rootkit_os:
  let w = 64
  let app = "lightblue"
  let os = layer(beside(~sep: 16, linux, windows_logo, macos), "lightgreen", 4 * w)
  stack(~sep: 4,
        beside(~sep: (os.width - 3 * w) / 2,
               layer(c, app, w), layer(c, app, w), layer(javascript, app, w)),
        layer(meta_bug.scale(0.2), "pink", os.width, ~height: 0.75),
        os)

slide(~title: "Rootkits",      
      slide.align(
        para(@{A @defterm{rootkit} modifies the OS to intercept},
             @{and change system actions}),
        blank(),
        slide.center(rootkit_os),
        slide.next,
        blank(32),
        slide.left(
          ~sep: 32,
          slide.left(
            ~sep: 8,
            para(@{Sits between applications and the kernel, so it can control applications}),
            example(@para{e.g., log keystrokes, redirect TCP connections, disable TLS})
          ),
          slide.left(
            ~sep: 8,
            para(@{Can change or lie to system tools to hide its own existence}),
            example(@para{e.g., change @tt{ls} or @tt{ps}})
          ),
          para(@{May change the bootloader to ensure that the},
               @{rootkit stays in place})
        )
      ))

slide(~title: "Malware Lifecycle",
      block:
        let sep = 8
        let vsep = 40
        fun detection(p):
          pin(~on: p,
              ~at: Find.right(p, ~dx: -64, ~dy: -120),
              delay(
                balloon.note(lines(@para{If we can't stop},
                                   @para{malware, which of},
                                   @para{these steps might},
                                   @para{be detected?})),
                6))
        beside.top(
          ~sep: 180,
          stack.left(
            ~sep: vsep,
            stack.left(
              ~sep: sep,              
              @para{Before intrusion:},
              @item{network reconnaisance},
              @item{determine software versions},
              @item{gather information on users}
            ),
            detection(delay(
                        stack.left(
                          ~sep: sep,              
                          @para{Intrusion:},
                          @item{buffer overflow},
                          @item{code injection},
                          @item{password guessing},
                          @item{phishing / social engineering}
                        ),
                        1
                      )),
            delay(stack.left(
                    ~sep: sep,              
                    @para{@defterm{Privilege escalation}:},
                    @item{access more powerful machine},
                    @item{access root user}
                  ),
                  2)
          ),
          stack.left(
            ~sep: vsep,
            delay(stack.left(
                    ~sep: sep,              
                    @para{Exploitation:},
                    @item{theft},
                    @item{destruction},
                    @item{surveilance}
                  ),
                  3),
            delay(stack.left(
                    ~sep: sep,              
                    @para{Access maintenance:},
                    @item{turn off updates},
                    @item{create accounts},
                    @item{steal credentials},
                    @item{install back door}
                  ),
                  4),
            delay(stack.left(
                    ~sep: sep,              
                    @para{Cover up:},
                    @item{delete files},
                    @item{erase logs}
                  ),
                  5)
          )))

slide(~title: "Intrusion Detection",
      slide.align(
        @para{Red flags that are relatively simple to detect:},
        @item{port scanning},
        @item{modifications to system files},
        @item{frequency of unusual system calls},
        slide.next,
        blank(32),
        @para{More generally:},
        item(@{@defterm{Anomaly-based systems} watch for unusual activity based on},
             @{a model of normal activity}),
        block:
          let patterns = @t{patterns}
          let p:
            item(@{@defterm{Signature-based systems} watch for specific activity based on},
                 @{@patterns for known malware})
          switch(p,
                 balloon.pin(~on: p,
                             ~at: Find.bottom(patterns),
                             ~spike: #'nw,
                             switch(
                               @para{Effective against script-kiddie attacks},
                               @para{Snort software and database is a popular choice}
                             )))
      ))

def goes_to = radial.arrow(~length: 24, ~fill: "purple")
def goes_to_up = radial.arrow(~length: 24, ~fill: "purple", ~rotate: 3/4*math.pi)

slide(~title: "Package Repositories",
      @para{A concern for programmers: @italic{Can you trust that library?}},
      blank(),
      slide.align(
        @para{Recently in the news: attempted @tt{xz} back door},
        slide.next,
        blank(),
        @para{Package repos have various mechanisms to prevent attacks and back doors},
        slide.next,
        blank(),
        para(@{@bold{Guix} package manager uses Git-like hashing to ensure whole},
             @{build and dependency chains are secure})
      ),
      lines(block:
              let p = @para{small Scheme interpreter in C}
              switch(nonarchival(p),
                     balloon.pin(~on: p,
                                 ~at: Find.right(p),
                                 ~spike: #'w,
                                 ~dx: -64,
                                 lines(@para{Goal is a small and},
                                       @para{auditable starting point}))),
            @para{@goes_to tiny C compiler in Scheme @goes_to_up},
            @para{@goes_to @tt{tinycc} compiler},
            @para{@goes_to very old @tt{gcc}},
            @para{@goes_to modern @tt{gcc}},
            @para{@goes_to ...}))

slide(~title: "Summary",
      slide.align(
        ~sep: 2 * slide.gap,
        @para{@defterm{Malware} does what you don't want, and on purpose},
        para(@{Malware delivery mechanisms: @defterm{trojan horse},},
             @{@defterm{virus}, @defterm{worm}}),
        @para{A @defterm{rootkit} owns a machine},
        para(@{Even if you write bug-free software, you have to build on complex},
             @{layers that will still have bugs for the forseeable future, so you'll need},
             @{security in commensurate depth})
      ))
