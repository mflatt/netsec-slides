#lang rhombus/static/and_meta
import:
  slideshow open
  "common.rhm" open

def terms:
  ["application layer",
   "network layer",
   "transport layer",
   "link layer",
   "physical layer",
   "layer 1",
   "layer 2",
   "layer 3",
   "propagation delay",
   "transmission delay",
   "processing delay",
   "queueing delay",
   "round-trip time (RTT)",
   "ping",
   "ICMP",
   "message",
   "time-to-live (TTL)",
   "traceroute",
   "latency",
   "throughput",
   "internet address",
   "port number",
   "TCP",
   "UDP",
   "name resolution",
   "DNS",
   "sockets",
   "well-known port numbers",
   "ephemeral port numbers",
   "connection-oriented",
   "connectionless",
   "state machine",
   "reliable data transmission",
   "checksum",
   "timeout",
   "exponential backoff",
   "send buffer",
   "receive buffer",
   "send base",
   "receive base",
   "window",
   "go-back-N",
   "cumulative ACK",
   "selective repeat",
   "TCP listener",
   "TCP connection",
   "segment",
   "sequence number",
   "acknowldgement number",
   "TCP handshake",
   "flow control",
   "congestion control",
   "SYN",
   "ACK",
   "FIN",
   "slow start",
   "congestion avoidance",
   "fast recovery",
   "handshake hell",
   "head-of-line problem",
   "ossification",
   "QUIC",
   "IP prefix",
   "subnet",
   "IP broadcast",
   "DHCP",
   "router",
   "forwarding table",
   "flow table",
   "software-defined networking (SDN)",
   "IPv4",
   "packet",
   "IPv6",
   "network address translation (NAT)",
   "tunnelling",
   "Dijkstra's algorithm",
   "Bellman-Ford",
   "link state",
   "distance vector",
   "autonomous system (AS)",
   "border gateway",
   "border gateway protocol (BGP)",
   "hot-potato routing",
   "IP anycast",
   "switch",
   "parity",
   "cyclic redundancy check (CRC)",
   "time-division multiplexing (TDM)",
   "frequency-division multiplexing (FDM)",
   "turn-taking",
   "polling",
   "token-passing",
   "random-access link",
   "carrier-sense multiple access (CSMA)",
   "CSMA/collision detection (CSMA/CD)",
   "DOCSIS",
   "medium access control (MAC)",
   "address resolution protocol (ARP)",
   "hub",
   "top-of-racket (TOR) switch",
   "local area network (LAN)",
   "vitrual LAN",
   "ethernet",
   "frame",
   "cryptography",
   "confidentiality",
   "integrity",
   "authentication",
   "non-repudiation",
   "cipher",
   "encrypt",
   "decrypt",
   "shared secret",
   "symmetic key",
   "asymmetric key",
   "ciphertext-only attack",
   "known-plaintext attack",
   "chosen-plaintext attack",
   "substitution",
   "permutation",
   "chaining",
   "key size",
   "block size",
   "random number generation (RNG)",
   "pseudo-random number generation (PRNG)",
   "cryptographically secure PRNG (CSPRNG)",
   "stream cipher",
   "RC4",
   "ChaCha",
   "block cipher",
   "key schedule",
   "Feistel structure",
   "Data Encryption Standard (DES)",
   "3DES",
   "Advanced Encryption Standard (AES)",
   "one-way function",
   "reversible function",
   "cipher block chaining (CBC)",
   "cryptographic hash functions",
   "message authentication code (MAC)",
   "MD5",
   "SHA-1",
   "SHA-2",
   "SHA-3",
   "hashing salt",
   "public-key cryptography",
   "Diffie-Hellman",
   "discrete logarithm problem",
   "RSA",
   "prime factorization",
   "elliptic curve",
   "elliptic-curve cryptography",
   "elliptic curve Diffie-Hellman (ECDH)",
   "electronic cookbook (ECB)",
   "output feedback (OFB)",
   "counter (CTR)",
   "Galois/counter with MAC (GCM)",
   "authentication",
   "replay attack",
   "certificate",
   "certificate chain",
   "root certificates",
   "session key",
   "perfect forward secrecy"].map(t)

fun groups(l :~ List, n):
  if l.length() <= n
  | [l]
  | List.cons(l.take_left(n), groups(l.drop_left(n), n))

fun term_slides(terms :~ List, cols :~ List):
  unless terms == []
  | let N = 12 * cols[0]
    let terms :~ List:
      if terms.length() < N
      | terms ++ for List (i: 0..(N-terms.length())): blank()
      | terms
    slide(~title: "Terminology",
          table(~vsep: 16,
                ~hsep: 48,
                groups(terms.take_left(N), cols[0])))
    term_slides(terms.drop_left(N), cols.rest)

term_slides(terms, [4, 3, 2, 2, 2, 2])

slide(~title: "Sample Midterm",
      @para{See @tt{sample_midterm.pdf}})
