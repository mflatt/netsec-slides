#lang rhombus/static/and_meta
import:
  rhombus/runtime_path
  "common.rhm" open
  "layers.rhm"
  "layout.rhm"  

module ~early icon ~lang rhombus/static/and_meta:
  import:
    rhombus/runtime_path
    "common.rhm" open

  export:
    router
    switchbox
    laptop
    server
    wifi
    house

  runtime_path.def router_png: "images/router.png"
  runtime_path.def switch_png: "images/switch.png"
  runtime_path.def laptop_png: "images/laptop.png"
  runtime_path.def server_png: "images/server.png"
  runtime_path.def wifi_png: "images/wifi-ap.png"
  runtime_path.def house_png: "images/house.png"
  def router = bitmap(router_png).scale(0.5).pad(~horiz: 5)
  def switchbox = bitmap(switch_png).pad(~horiz: 5)
  def laptop = bitmap(laptop_png).scale(0.15)
  def server = bitmap(server_png).scale(0.1)
  def wifi = bitmap(wifi_png).scale(0.2)
  def house = bitmap(house_png).scale(0.2)

import self!icon open

module ~early pkt ~lang rhombus/static:
  import:
    "common.rhm" open
  export:
    pkt_up_to_layers
    pkt_ize
    dest_addr
  def dest_addr = @tt{141.193.213.10}
  fun pkt_layers(i, options :~ OptMap):
    if i == 0
    | []
    | let content :~ Pict:
        match i
        | 1: lines(@tt{GET / HTTP/1.1},
                   @tt{Host: cs.utah.edu})
        | 2: lines(@bold{TCP},
                   @para{src port: @tt{7786}},
                   if options[#'dest] | @para{dest port: @tt{80}} | nothing)
        | 3: lines(@bold{IP},
                   @para{src: @tt{10.0.1.23}},
                   if options[#'dest] | @para{dest: @dest_addr} | nothing)
        | 4: lines(@bold{Ethernet},
                   @para{src: @tt{A0-44-5F-63-8B-BC}},
                   if options[#'dest]
                   | @para{dest: @(block:
                                     let p = @tt{00-00-0C-9F-F0-C4}
                                     if options[#'unknown_dest]
                                     | overlay(p.ghost(), @tt{???})
                                     | p)}
                   | nothing)
      [content.scale(0.5), & pkt_layers(i-1, options)]
  fun same_height([p :~ Pict, ...]):
    let h = math.max(0, p.height, ...)
    let [p, ...] = [p.pad(~horiz: 4), ...]
    [rectangle(~around: p, ~height: h,
               ~line: "blue", ~fill: "lightblue"),
     ...]
  fun pkt_up_to_layers(i, options = {}) :~ Pict:
    beside(& same_height(pkt_layers(i, options)))
  fun pkt_ize(ps) :~ Pict:
    beside(& same_height(ps))

import:
  self!pkt

module ~early layers ~lang rhombus/static:
  import:
    parent!icon open
    parent!pkt
    "common.rhm" open
    "layers.rhm"

  export:
    all_layers_slides

  fun all_layers_slides(~title: title = "Layers",
                        ~crc = #false,
                        ~steps = !crc,
                        ~highlight = #true,
                        ~show_why = #false):
    let app_layer_pip = blank()
    let link_layer_pip = blank()
    let [[name, examples, interface], ...] = layers.make()
    fun adj_intf(name, interface):
      match name
      | "transport": @italic{messages}
      | "network": @italic{segments}
      | "link": @italic{packets}
      | "physical": @italic{frames}
      | ~else: nothing
    let made = [[name, examples, adj_intf(name, interface)], ...]
    fun add_number(p, i) :~ Pict:
      let n :~ Pict:
        if i == 0
        | t("5–7")
        | t(to_string(5 - i))
      beside(~sep: 16,
             n.colorize("blue"),
             p)
        .refocus(p)
    fun add_pip(p, i):
      match i
      | 0: beside(app_layer_pip, p)
      | 3: beside(link_layer_pip, p)
      | ~else: p
    fun add_number_and_router(p, i):
      let p = add_number(p, i)
      let p = add_pip(p, i)
      let (str, bm):
        cond
        | !highlight: values(#false, #false)
        | i == 2: values("routers", router.scale(0.5))
        | i == 3: values("switches", switchbox.scale(0.5))
        | ~else: values(#false, #false)
      if str
      | beside(~sep: 64,
               beside(~sep: 16, t(str).colorize("forestgreen"), bm),
               p)
          .refocus(p)
      | p
    fun add_pkt(p, i, ~do_refocus = #true):
      if p == nothing
      | p
      | let pp = beside(~sep: 32, p, pkt.pkt_up_to_layers(i))
        if do_refocus
        | pp.refocus(p)
        | pp
    fun add_pkt_with_checksum(p, i):
      let pkt :~ Pict = add_pkt(p, i, ~do_refocus: #false)
      let pkt :~ Pict:
        if pkt == nothing
        | pkt
        | pkt.refocus(p)
      let pkt :~ Pict:
        match i
        | 2 || 3 || 4: balloon.pin(~on: pkt,
                                   ~at: Find.right_top(pkt, ~dx: 64, ~dy: 16),
                                   ~spike: #'sw,
                                   if i == 4
                                   | @para{CRC}
                                   | @para{checksum})
        | ~else: pkt
      pkt

    slide(~title: title,
          switch(
            if steps
            | switch(
                layers.pict(made),
                layers.pict(made, ~highlight: "link"),
                animate(fun (n):
                          layers.pict(made, ~interfaces: n,
                                      ~highlight: "link",
                                      ~adjust: add_number),
                        ~sustain_edge: #'after).sustain(),
                layers.pict(made, ~interfaces: #true,
                            ~highlight: "link",
                            ~adjust: add_number,
                            ~adjust_interface: add_pkt)
                )
            | nothing,
            block:
              let p:
                layers.pict(made, ~interfaces: #true,
                            ~highlight: highlight && "link",
                            ~adjust: add_number_and_router,
                            ~adjust_interface: add_pkt)
              if show_why
              | let p2:
                  balloon.pin(~on: p,
                              ~at: Find.left(app_layer_pip),
                              ~spike: #'e,
                              lines(@para{When building systems, we},
                                    @para{mostly get to work at this},
                                    @para{level of abstraction}))
                let p3:
                  balloon.pin(~on: p2,
                              ~at: Find.left(link_layer_pip),
                              ~spike: #'e,
                              lines(@para{Attacks sometimes},
                                    @para{work by breaking a},
                                    @para{leaky abstraction}))
                switch(p, p2, p3)
              | p,
            if crc
            | layers.pict(made, ~interfaces: #true,
                          ~highlight: "link",
                          ~adjust: add_number_and_router,
                          ~adjust_interface: add_pkt_with_checksum)
            | nothing
          ))

import self!layers open
all_layers_slides(~crc: #true)

slide(~title: "Weak: Parity",
      lines(~horiz: #'right,
            @para{A 1-bit checksum is a @defterm{parity} check},
            @para{... since that 1 bit is either on/odd or off/even}.scale(0.75)),
      table([[@tt{10001010}, @t{→}, @tt{1}],
             [@tt{10011010}, @t{→}, @tt{0}],
             [@tt{10111010}, @t{→}, @tt{1}]]),
      slide.next,
      blank(48),
      @lines(@para{Fast, but two corrupt bits cancel, which is}
             @para{especially bad when corruption is bursty}),
      table([[@tt{10001010}, @t{→}, @tt{1}],
             [beside(@tt{1}, @boldly(@tt{11}).colorize("red"), @tt{01010}), @t{→}, @tt{0}]])
      )

block:
  let sums = line(~dx: @tt{10001010}.width)
  slide(~title: "Better: Checksum",
        @para{Adding numbers and keeping low bits is better},
        blank(),
        table([[@tt{10001010}, blank(), @beside(@tt{1},@(@boldly{@tt{111}}.colorize("red")), @tt{1010})],
               [@tt{10011110}, blank(), @beside(@tt{10011110})],
               [@tt{10111010}, blank(), @beside(@tt{10111010})],
               [@tt{10111110}, blank(), @beside(@tt{10111110})],
               [sums, blank(), sums],
               [@tt{10100000}, @t{≠}, @beside(@tt{0}.colorize("red"), @tt{0}, @tt{01}.colorize("red"), @tt{0000})]],
              ~hsep: 50),
        slide.next,
        blank(),
        @para{But it can miss many kinds of regular patterns},
        table([[@tt{10001010}, blank(), @beside(@tt{10001},@boldly(@tt{1}.colorize("red")), @tt{10})],
               [@tt{10011110}, blank(), @beside(@tt{10011},@boldly(@tt{0}.colorize("red")), @tt{10})],
               [@tt{10111010}, blank(), @beside(@tt{10111},@boldly(@tt{1}.colorize("red")), @tt{10})],
               [@tt{10111110}, blank(), @beside(@tt{10111},@boldly(@tt{0}.colorize("red")), @tt{10})],
               [sums, blank(), sums],
               [@tt{10100000}, @t{=}, @tt{10100000}]],
              ~hsep: 50))
          
def long_division1:
  fun total(p :~ Pict): stack(p, line(~dx: p.width, ~line_width: 2))
  stack.right(total(@tt{  2871088}),
              beside.top(~sep: 5, @tt(to_string(43)), @roman{⟌}.pad(~right: -5, ~top: 1),
                         stack(~horiz: #'left,
                               ~order: #'back,
                               @tt{123456789},
                               @tt{ 86},
                               @tt{ 374},
                               beside(@tt{ }, total(@tt{344})),
                               @tt{  305},
                               beside(@tt{  }, total(@tt{301})),
                               @tt{    46},
                               beside(@tt{    }, total(@tt{43})),
                               @tt{     37},
                               beside(@tt{     }, total(@tt{ 0})),
                               @tt{     378},
                               beside(@tt{     }, total(@tt{344})),
                               @tt{      349},
                               beside(@tt{      }, total(@tt{344})),
                               beside(@tt{        }, rectangle(~around: @tt{5}, ~fill: "beige")))))
    .scale(0.85)

def long_division2 :~ Pict:
  fun total(p :~ Pict): stack(p, line(~dx: p.width, ~line_width: 2))
  stack.right(total(beside(@tt{  287}, @tt{3413}.colorize("red"), @tt{})),
              beside.top(~sep: 5, @tt(to_string(43)), @roman{⟌}.pad(~right: -5, ~top: 1),
                         stack(~horiz: #'left,
                               ~order: #'back,
                               beside(@tt{123}, @boldly{@tt{5}}.colorize("red"), @tt{56789}),
                               @tt{ 86},
                               beside(@tt{ 37}, @tt{5}.colorize("red")),
                               beside(@tt{ }, total(@tt{344})),
                               beside(@tt{  3}, @tt{1}.colorize("red"), @tt{5}),
                               beside(@tt{  }, total(@tt{301})),
                               beside(@tt{   1}.colorize("red"), @tt{46}),
                               beside(@tt{   }, total(@tt{129}.colorize("red"))),
                               beside(@tt{    17}.colorize("red"), @tt{7}),
                               beside(@tt{    }, total(@tt{172}.colorize("red"))),
                               beside(@tt{     05}.colorize("red"), @tt{8}),
                               beside(@tt{     }, total(beside(@tt{0}.colorize("red"), @tt{4}, @tt{3}.colorize("red")))),
                               beside(@tt{      15}.colorize("red"), @tt{9}),
                               beside(@tt{      }, total(@tt{129}.colorize("red"))),
                               beside(@tt{       }, rectangle(~around: @tt{30}.colorize("red"), ~fill: "beige")))))
    .scale(0.85)

block:
  let crc_title = "Strong: Cyclic Redundancy Check"
  slide(~title: crc_title,
        @para{@bold{Division} is much better at mixing numbers},
        block:
          let p = animate(fun (n):
                            beside(~sep: 50,
                                   long_division1,
                                   long_division2.scale(n, 1))).sustain()
          slide.alts(
            p,
            beside(~sep: 80,
                   p.snapshot(1),
                   lines(@para{General division is},
                         @para{ expensive on a CPU},
                         blank(10),
                         @para{Specialized division},
                         @para{can be fast, especially},
                         @para{in hardware}).colorize("blue"))
              .refocus(p)
          ))
  let d = @romanly{@italic{d}}
  let D = @romanly{@italic{D}}
  let r = @romanly{@italic{r}}
  let R = @romanly{@italic{R}}
  let G = @romanly{@italic{G}}
  let eqls = @romanly{=}
  let standard = @t{IEEE standard}
  slide(~title: crc_title,
        slide.align(
          @para{A @defterm{cyclic redundancy check (CRC)} takes advantage of division:},
        ),
        beside(~sep: 16, R, eqls,
               @romanly{remainder of},
               romanly: frac(@t{@D × 2@superscript{@r}}, G)).pad(~vert: 32),
        table([[d, eqls, @para{number of bits to check}],
               [D, eqls, @para{@d bits of data}],
               [r, eqls, @para{bits for hash result (typically 8, 12, 16, or 32)}],
               [G, eqls, @para{a carefully chosen, agreed-on @t{@romanly{@r+1}-bit} number}],
               [R, eqls, @para{the result for @D}]]),
        slide.next,
        blank(),
        block:
          let p = @para{For @r @eqls 32, @standard is @G @eqls @tt{0x104C11DB7}}
          slide.alts(p,
                     balloon.pin(~on: p,
                                 ~at: Find.bottom(standard),
                                 ~spike: #'nw,
                                 @para{Detects any @(r)-bit error burst}))
      )


let payload:
  layout.row(layout.field(16, @t{payload}, ~varies: #true, ~height: 5, ~inset: 1))

let dest_field = layout.field(6, @t{dest})
let source_field = layout.field(6, @t{source})
let CRC_field = layout.field(4, @t{CRC})
let type_field = layout.field(2, @t{type})

let bitless_ethernet_frame:
  layout.record(layout.row(dest_field,
                           source_field,
                           type_field,
                           layout.field(2, nothing)),
                payload,
                layout.row(layout.field(12, nothing),
                           CRC_field))

let ethernet_frame:
  layout.record(~bytes: 16,
                bitless_ethernet_frame)

slide(
  ~title: "Ethernet Frame Layout",
  slide.alts(
    ethernet_frame,
    balloon.pin(~on: ethernet_frame,
                ~at: Find.left(dest_field, ~dx: 5),
                ~spike: #'e,
                @para{destination MAC}),
    balloon.pin(~on: ethernet_frame,
                ~at: Find.left(source_field, ~dx: 5),
                ~spike: #'e,
                ~dx: 64,
                @para{source MAC}),
    balloon.pin(~on: ethernet_frame,
                ~at: Find.right(type_field, ~dx: -5),
                ~spike: #'w,
                ~dx: -64,
                @para{IP}),
    balloon.pin(~on: ethernet_frame,
                ~at: Find.right(payload, ~dx: -5),
                ~spike: #'w,
                @para{between 46 and 1500 bytes}),
    balloon.pin(~on: layout.record(~bytes: 16,
                                   rectangle(~around: bitless_ethernet_frame,
                                             ~line: #false,
                                             ~fill: "yellow")),
                ~at: Find.right(CRC_field, ~dx: -5),
                ~spike: #'w,
                @para{CRC for the whole frame})
  )
)

let preamble_field = layout.field(7, @t{preamble})
let sfd_field = layout.field(1, @t{SFD})

let ethernet_physical_frame:
  layout.record(~bytes: 16,
                layout.row(layout.field(8, nothing),
                           preamble_field,
                           sfd_field), 
                bitless_ethernet_frame,
                layout.row(layout.field(12, @t{inter-packet gap}),
                           layout.field(4, nothing)))

slide(
  ~title: "Ethernet Physical Layer Layout",
  slide.alts(
    ethernet_physical_frame,
    block:
      let p:
        balloon.pin(~on: ethernet_physical_frame,
                    ~at: Find.top(preamble_field, ~dy: 5),
                    ~dy: 64,
                    ~spike: #'s,
                    @para{Seven @tt{10101010}s to sync})
      slide.alts(
        p,
        balloon.pin(~on: p,
                    ~at: Find.right(sfd_field, ~dx: -5),
                    ~spike: #'w,
                    @para{One @beside.baseline(@tt{1010101}, @tt{1}.colorize("red"))})
      )
  )
)

slide(
  ~title: "Ethernet Physical Layer",
  slide.align(
    @para{Originally, machines on an ethernet LAN shared a wire},
    blank(),
    @para(@List{Modern ethernet is always @t{@defterm{switched}:} there's a dedicated wire},
          @List{from each machine to the switch}),
    slide.right(
      @para{This makes MAC addresses somewhat redundant!}.colorize("blue").scale(0.75)
    ),
    slide.next,
    blank(),
    @para(@List{Many ethernet frames are not physically ethernet at all, because},
          @List{the easiest way to create a new physical layer is to emulate an ethernet device})
  )
)

let color1 = "red"
let color2 = "forestgreen"
let color3 = "blue"
let color4 = "purple"

slide(
  ~title: "Coordinating Communication",
  @para{@bold{Easy mode}: point-to-point communication},
  blank(),
  block:
    let p = beside(~sep: 200, laptop, switchbox)
    connect(~on: p, Find.right(laptop), Find.left(switchbox), ~line_width: 3),
  slide.next,
  blank(),
  @para{@bold{Hard mode}: shared communication medium},      
  blank(),
  block:
    let l1 = laptop.launder()
    let l2 = laptop.launder()
    let l3 = laptop.launder()
    fun out(p :~ Pict, angle, color) :~ Pict:
      fun mk(size):
        let size = math.max(p.width + size, p.height + size)
        circle(~size: size,
               ~arc: #'ccw,
               ~start: angle - pi * 1/8, ~end: angle + pi * 1/8,
               ~line: color)
      overlay(p, mk(64), mk(128), mk(192)).refocus(p)
    let p:
      stack(~horiz: #'left,
            ~sep: 32,
            beside(~sep: 250, out(l1, 0, color3), out(out(wifi, -pi, "purple"), -3/5*pi, color4)),
            out(l2, pi * 1/5, color1).pad(~left: 100),
            out(l3, pi * 1/4, color2).pad(~left: 200).scale(0.9))
    switch(
      p,
      balloon.pin(~on: p,
                  ~at: Find.right(p),
                  ~spike: #'w,
                  lines(@para{Goals:},
                        @item{divide bandwidth fairly},
                        @item{@lines(@para{only one active}
                                     @para{⇒ gets full bandwidth})}))
    )

)

fun sequence(elems :~ List):
  for List (e: elems,
            i: 0..):
    (for List (j: 0..i): nothing)
      ++ [e]
      ++ (for List (j: 0 .. elems.length()-i-1): nothing)

def dots = @t{···}.scale(2).pad(32)

fun add_vline(p :~ Pict) :~ Pict:
  let l = line(~dy: p.height).colorize("lightgray")
  beside(l, p, l)

slide(
  ~title: "Shared-Medium Strategy 1: Channel Partitioning",
  slide.align(
    @para{@defterm{Time-division multiplexing (TDM)}:},
    block:
      fun mk(color, n):
        overlay(rectangle(~width: 32, ~height: 48, ~fill: color),
                t(to_string(n)).colorize("white"))
      let slot1 = mk(color1, 1)
      let slot2 = mk(color2, 2)
      let frame = add_vline(table(sequence([slot1, slot2, mk(color3, 3), mk(color4, 4)]),
                                  ~vsep: 0,
                                  ~hsep: 0,
                                  ~vline: "lightgray"))
      let frame2 = frame.launder()
      let p:
        beside(frame, frame2, frame.launder(), frame.launder())
      let p:
        stack(~horiz: #'left, @t{@italic{time} →}, p).refocus(p)
      let p:
        beside(dots.pad(~right: 5), p, dots)
      fun desc(p, q :~ Pict, label, ~horiz = #'center) :~ Pict:
        let brace = @roman("{").pad(~vert: -2)
        let brace = brace.scale(q.width / brace.height)
        let brace = brace.scale(16 / brace.width, 1)
        let brace = brace.rotate(pi * 1/2)
        pin(~on: p,
            ~at: Find.left_bottom(q),
            stack(~horiz: horiz, brace, label).refocus(brace))
      let p0 = p.pad(~vert: 32)
      let p1 = desc(p0, slot2, @defterm{slot}.pad(~right: 10), ~horiz: #'right)
      let p2 = desc(p1, frame2, @defterm{frame})    
      switch(p0, p1, p2)
  ),
  slide.next,
  blank(),
  slide.alts(
    lines(@para{@defterm{Frequency-division multiplexing (FDM)}:},
          @para{same idea, but for simultaneous frequencies}.pad(~horiz: 32)),
    slide.align(
      @item(~bullet: plus){No collisions},
      @item(~bullet: plus){Perfectly fair},
      @item(~bullet: minus){Poor utilization when some are idle}
    )
  )
)

slide(
  ~title: "Shared-Medium Strategy 2: Turn Taking",
  block:
    fun mk(msg :~ Pict, color, width = 0):
      let msg = msg.pad(3)
      overlay(~horiz: #'right,
              rectangle(~width: math.max(width, msg.width), ~height: msg.height, ~fill: color),
              msg)
    fun ask(color, n, ~msg = "?"):
      let t = @bold(msg).colorize(color)
      ellipse(~around: t.pad(2), ~line: #false, ~fill: Color("white") with (alpha = 0.5))
    let quiet = @bold{ }.pad(2)
    let yes1 = mk(quiet, color1, 50)
    let ask2 = mk(ask(color2, 2), color1)
    let ask3 = mk(ask(color3, 3), color1)
    let ask4 = mk(ask(color4, 4), color1)
    let no2 = mk(quiet, color2, 16)
    let yes2 = mk(quiet, color2, 70)
    let yes3 = mk(quiet, color3, 100)
    let no4 = mk(quiet, color4, 16)
    let yes4 = mk(quiet, color4, 70)
    fun frame(ans2, ans3, ans4):
      add_vline(table([[ask2, nothing, ask3, nothing, ask4, nothing],
                       [nothing, ans2, nothing, nothing, nothing, nothing],
                       [nothing, nothing, nothing, ans3, nothing, nothing],
                       [nothing, nothing, nothing, nothing, nothing, ans4]],
                      ~vline: "lightgray",
                      ~vsep: 0,
                      ~hsep: 0))
    let polling:
      stack(~sep: 64, ~horiz: #'left,
            @para{@defterm{Polling}:},
            block:
              let p = beside(dots,
                             frame(no2, yes3, no4), frame(no2, yes3, no4), frame(no2, yes3, yes4),
                             dots)
              switch(p,
                     balloon.pin(~on: p,
                                 ~at: Find.top(p, ~dy: p.height/8, ~dx: -p.width/6),
                                 ~dy: 32,
                                 ~spike: #'sw,
                                 @para{One node acts as the leader and polls others}),
                     balloon.pin(~on: p,
                                 ~at: Find.center(p, ~dy: p.height/8),
                                 ~dy: -128,
                                 ~spike: #'n,
                                 @para{A node with data to send gets a larger (but limited) window}),
                     p))
    let next2 = mk(ask(color2, 1, ~msg: "!"), color1)
    let next3 = mk(ask(color3, 2, ~msg: "!"), color2)
    let next4 = mk(ask(color4, 3, ~msg: "!"), color3)
    let next1 = mk(ask(color1, 4, ~msg: "!"), color4)
    fun token_frame(ans1, ans4):
      add_vline(table([[ans1, nothing, nothing, nothing],
                       [nothing, next3, nothing, nothing],
                       [nothing, nothing, beside(yes3, next4), nothing],
                       [nothing, nothing, nothing, ans4]],
                      ~vline: "lightgray",
                      ~vsep: 0,
                      ~hsep: 0))
    let token_passing:
      let p:
        stack(~sep: 64, ~horiz: #'left,
              @para{@defterm{Token passing}:},
              beside(dots,
                     token_frame(next2, next1),
                     token_frame(next2, next1),
                     token_frame(beside(yes1, next2), beside(yes4, next1)),
                     dots))
      switch(p,
             balloon.pin(~on: p,
                         ~at: Find.left_top(p, ~dx: p.width * 1/4, ~dy: p.height * 3/4),
                         ~spike: #'n,
                         ~sprout: 0.2,
                         ~dy: -92,
                         @para{A node sends data, if any, then notifies next}),
             p)
    switch(
      stack(~sep: 32,
            & sequential(~join: #'splice,
                         polling,            
                         slide_pict(
                           blank(),
                           slide.align(
                             @item(~bullet: plus){Better utilization},
                             @item(~bullet: minus){Polling causes delays},
                             @item(~bullet: minus){Recovery needed if the leader fails}
                           )))),
      stack(~sep: 32,
            & sequential(~join: #'splice,
                         token_passing,            
                         slide_pict(
                           blank(),
                           slide.align(
                             @item(~bullet: plus){Better utilization},
                             @item(~bullet: minus){Token-passing causes delays},
                             @item(~bullet: minus){Recovery needed if any fails}
                           ))))
    )
)

block:
  def c1 = color1
  def c2 = color2
  def c3 = color3
  def c4 = color4
  fun msg(color, n) :~ Pict:
    rectangle(~width: n * 64, ~height: 48, ~fill: color)
  def oops :~ Pict:
    let p = @bold{!}
    p.scale(48 / p.height).pad(~horiz: 10)
  let p:
    add_vline(table([[msg(c1, 1), nothing, nothing,     nothing,  msg(c1, 1), oops.colorize(c1), nothing, nothing],
                     [nothing,    nothing, msg(c2, 2),  nothing,  nothing, nothing, msg(c2, 2), oops.colorize(c2)],
                     [nothing,    nothing, nothing,     nothing,  msg(c3, 1), oops.colorize(c3), nothing, nothing],
                     [nothing,    nothing, nothing,     msg(c4, 2), nothing, nothing, overlay.right(msg(c4, 2).ghost(), msg(c4, 1)), oops.colorize(c4)]],
                    ~vert: #'top,
                    ~vline: "lightgray",
                    ~vsep: 0,
                    ~hsep: 0))
  let p: beside(dots, p, dots)
  slide(
    ~title: "Shared-Medium Strategy 3: Random Access",
    slide.align(
      @para{@defterm{Random access}:},
      blank(28),
      p.pad(~horiz: 36),
      slide.next,
      blank(),
      slide.center(
        @item(~bullet: minus.ghost()){Need collision detection and/or @defterm{carrier sense}},
        @item(~bullet: minus.ghost()){Random delay when collision is detected},
        slide.next,
        @item(~bullet: plus){Potentially better utilization}
      )
    )
  )

fun mk_ra(color, n):
  let r = rectangle(~width: 96, ~height: 48, ~fill: color, ~line: color && #'inherit)
  fun (msg):
    overlay(r, t(msg, subscript(to_string(n))).colorize("white"))
    
slide(
  ~title: "Random Access: ALOHA",
  blank(),
  block:
    fun mk(color, n): mk_ra(color, n)
    let send1 = mk(color1, 1)
    let send2 = mk(color2, 2)
    let send3 = mk(color3, 3)
    let send4 = mk(color4, 4)
    let result = Pict.ghost(mk("black", 0)(""))
    fun rst(s): t(s).scale(0.75)
    let success = overlay(@rst{success}, result)
    let conflict = overlay(@rst{conflict}, result)
    let empty = overlay(@rst{empty}, result)
    let success1 = success.launder()
    let conflict1 = conflict.launder()
    let empty1 = empty.launder()
    let p:
      add_vline(
        table([[nothing,    nothing,    send1("a"), send1("b"),   send1("c"), nothing,    nothing,    send1("c"), nothing],
               [nothing,    nothing,    nothing,    nothing,      send2("a"), send2("a"), nothing,    nothing,    nothing],
               [send3("a"), send3("b"), nothing,    nothing,      nothing,    nothing,    nothing,    nothing,    nothing],
               [nothing,    nothing,    nothing,    nothing,      send4("a"), nothing,    nothing,    send4("a"), send4("a")],
               [success1,   success,    success,    success,      conflict1,  success,    empty1,     conflict,   success]],
              ~vline: "lightgray",
              ~hsep: 0,
              ~vsep: 0)
      )
    let p:
      beside(dots, p, dots)
    slide.alts(
      p,
      balloon.pin(~on: p,
                  ~at: Find.bottom(success1),
                  ~spike: #'n,
                  lines(@para{On success, a node can keep sending},
                        @para{as long as it has data})),
      balloon.pin(~on: p,
                  ~at: Find.bottom(conflict1),
                  ~spike: #'n,
                  lines(@para{On conflict, each node retries on},
                        @para{next slot probability @romanly{@italic{P}}})),
      balloon.pin(~on: p,
                  ~at: Find.bottom(empty1),
                  ~spike: #'n,
                  lines(@para{Sometimes, we waste slots due to},
                        @para{those random waits})),
      [p,
       blank(32),
       slide.align(
         @para{@defterm{Slotted ALOHA}, which needs synchronization:},
         @item(~bullet: plus){Sole active nodes can use full bandwidth},
         @item(~bullet: plus){Multiple active nodes get fair share},
         @item(~bullet: minus){Even after optimizing @t{@romanly{@italic{P}},} likely to get only 37% success}
       )]         ,
      [p,
       blank(32),
       slide.align(
         @para{Original @defterm{unslotted ALOHA} avoided synchronization:},
         @item(~bullet: minus){Success drop drops by half},
         slide.right(@para{because each local slot likely overlaps two other peer slots}.scale(0.75))
       )]
    )

)

let (csma_setup, csma_maker):
  fun send3(msg): mk_ra(color3, 3)(msg)
  fun send3g(msg): mk_ra(#false, 3)(msg)
  fun send1g(msg): mk_ra(#false, 1)(msg)
  let empty = Pict.ghost(send3("3"))
  let send1a :~ Pict = mk_ra(color1, 1)("a")
  let send3a :~ Pict = send3("a")
  let send3b :~ Pict = send3("b")
  let send3ga :~ Pict = send3g("a")
  let send3gb :~ Pict = send3g("b")
  let send1ga :~ Pict = send1g("a")
  fun mk_table(send3a, send3b, send1a,
               ~send1a_2: send1a_2 = nothing,
               ~send3a_2: send3a_2 = empty,
               ~send3b_2: send3b_2 = empty) :~ Pict:
    add_vline(
      table([[empty,    send1a,    send1a_2,   nothing,   nothing,      nothing,    nothing],
             [empty,    nothing,    empty,     nothing,   nothing,    nothing,    nothing],
             [empty,    send3a,     send3b,     empty,    send3a_2,    send3b_2,      empty],
             [empty,    nothing,    nothing,    nothing,   nothing,    nothing,    nothing],
             [empty,    nothing,    nothing,    nothing,   nothing,    nothing,    nothing]],
            ~vline: "lightgray",
            ~hsep: 0,
            ~vsep: 0)
    )
  fun cone(p :~ Pict, send :~ Pict, color, ~stop_at = #false):
    let (x, y) = Find.left(send).in(p)
    let slope = 2.5
    let dx_up = y / slope
    let dx_down = (p.height - y) / slope
    let w = if stop_at | stop_at * send.width | send.width
    pin(~on: p,
        ~at: Find.abs(0, 0),
        polygon([[x, y],
                 [x + dx_up, 0],
                 [x + dx_up + w, 0],
                 [x + w, y],
                 [x + w + dx_down, p.height],
                 [x + dx_down, p.height]],
                ~fill: Color(color) with (alpha = 0.5),
                ~line: #false),
        ~order: #'back)
  fun cones3(p, ~stop_at = #false, ~send3ga: send3ga = send3ga, ~send3gb: send3gb = send3gb):
    if stop_at
    |cone(p, send3ga, color3, ~stop_at: stop_at)
    | cone(cone(p, send3ga, color3), send3gb, color3)
  fun cones1(p, ~stop_at = #false, ~send1ga: send1ga = send1ga):
    cone(p, send1ga, color1, ~stop_at: stop_at)
  values(
    switch(
      mk_table(send3a, send3b, empty, ~send1a_2: send1a.alpha(0.3)).sustain(),
      cones3(mk_table(send3ga, send3gb, empty)),
      cones1(cones3(mk_table(send3ga, send3gb, send1ga)))
    ),
    slide.alts(
      block:
        let p = cones1(cones3(mk_table(send3ga, send3gb, send1ga)))
        switch(p,
               balloon.pin(~on: p,
                           ~at: Find.bottom(send3gb),
                           ~spike: #'n,
                           ~dy: -192,
                           @para{Don't send second when conflict is detected})),
      block:
        let p = cones1(cones3(mk_table(send3ga, Pict.ghost(send3gb), send1ga), ~stop_at: 1))
        switch(p,
               balloon.pin(~on: p,
                           ~at: Find.top(send1ga),
                           ~spike: #'s,
                           @para{Stop send in progress when conflict is detected})),
      block:
        let p = cones1(cones3(mk_table(send3ga, send3gb, send1ga), ~stop_at: 0.5), ~stop_at: 0.5)
        switch(p,
               balloon.pin(~on: p,
                           ~at: Find.top(send1ga, ~dx: 10),
                           ~spike: #'s,
                           @para{Some time need for conflict detection}),
               stack(~sep: 32,
                     balloon.note(@para{Random delay before retry}),
                     p).refocus(p),
               block:
                 let send3ga_2 = send3ga.launder()
                 let send3gb_2 = send3gb.launder()
                 let send1ga_2 = send1ga.launder()
                 let p = cones1(cones3(mk_table(send3ga, nothing, send1ga,
                                                ~send3a_2: send3ga_2,
                                                ~send3b_2: send3gb_2,
                                                ~send1a_2: send1ga_2),
                                       ~stop_at: 0.5),
                                ~stop_at: 0.5)
                 let p = cones1(p, ~send1ga: send1ga_2)
                 let p = cones3(p, ~send3ga: send3ga_2, ~send3gb: send3gb_2)
                 let efficiency:
                   let d_prop = @romanly(@italicly{d@subscript{prop}})
                   let d_trans = @romanly(@italicly{d@subscript{trans}})
                   let eql = @romanly{=}
                   beside(~sep: 128,
                          stack(~sep: 32,
                                @para{@d_prop @eql max delay for signal},
                                @para{@d_trans @eql max duration for frame}),
                          @para{efficiency @eql @frac(@romanly{1},
                                                      @romanly{1 + 5@frac(d_prop.pad(~bottom: 4), d_trans)})})
                 switch(p,
                        balloon.pin(~on: p,
                                    ~at: Find.top(send1ga_2),
                                    ~spike: #'s,
                                    @para{Sends and re-sends do not need slot synchronization}),
                        stack(~sep: 32,
                              balloon.note(lines(@para{Exponential back-off:},
                                                 @para{If another conflict, double average retry delay})),
                              p).refocus(p),
                        stack(~sep: 48, p, efficiency).refocus(p),
                        ))
    )
  )    

slide(
  ~title: "Random Access: Carrier Sense",
  lines(@para{@defterm{Carrier Sense Multiple Access (CSMA)} means},
        @para{``don't talk when someone else is talking''}.pad(~left: 64)),
  slide.next,
  blank(),
  block:
    let p:
      lines(@para{The catch: there's a delay between the time that one node sends},
            @para{and another node starts to sense it})
    switch(p.ghost(), p),
  csma_setup
)

slide(
  ~title: "Handling Conflicts in CSMA/CD",
  csma_maker
)

def CMTS = @t{CMTS}
def collide_pip = blank()

fun cable(options :~ OptMap):
  let w = 5
  let all_c = !options[#'colors] && "black"
  let c1 = all_c || "red"
  let c2 = all_c || "blue"
  let c3 = all_c || "forestgreen"
  let c4 = all_c || "orange"
  let lined_house = stack(house,
                          @t{modem}.scale(0.5),
                          line(~dy: 16, ~line_width: w))
  let p = beside(~sep: 32,
                 lined_house.colorize(c1),
                 lined_house.colorize(c2),
                 lined_house.colorize(c3),
                 lined_house.colorize(c4))
  let cable = line(~dx: p.width * 1.2, ~line_width: w)
  let h = 64
  let channel_color = "lightblue"
  fun arrow(p :~ Pict) :~ Pict:
    polygon([[0, h/2], [h/2, 0], [h/2, h/4], [p.width, h/4],
             [p.width, h*3/4], [h/2, h*3/4], [h/2, h]],
            ~fill: channel_color,
            ~line: #false)
  fun packets(p :~ Pict, [[col, w], ...]):
    if options[#'download]
    | let W = (p.width - h/2) / 5
      fun as_color(col): if col is_a Pict | #false | col
      fun as_pict(col): if options[#'sched] && col is_a Pict | col | nothing
      overlay.right(p, beside(overlay(rectangle(~width: w * W, ~height: h/2,
                                                ~fill: as_color(col) || "black",
                                                ~line: channel_color).ghost(!as_color(col)),
                                      as_pict(col)),
                              ...))
    | p
  fun slots(f, m :~ Map, q :~ Map):
    let N = 15
    let W = (p.width + h/2) / N
    if options[#'upload]
    | overlay.right(f, beside(& for List (i in 0..N):
                                let req = options[#'reqs] && ((i+1) mod 5 == 0)
                                let r:
                                  rectangle(~width: W, ~height: h/2,
                                            ~fill: m.get(i, if req | "gray" | #false),
                                            ~line: "black")
                                if req | overlay(r, q.get(i, t("?").colorize("lightgray"))) | r))
    | f
  fun sched(c2, c3, c4 = #false):
    let S = h/8
    let s2 = square(~fill: c3, ~size: S)
    stack(~sep: S / 4,
          square(~fill: c2, ~size: S),
          beside(~sep: S / 4,
                 s2,
                 square(~fill: c4, ~size: S).ghost(!c4)).refocus(s2))
  let (cable, pad_amt):
    let up = arrow(cable)
    let down = arrow(cable).rotate(pi).translate(h/2, 0)
    fun freq(f, p):
      beside(~sep: 5, @romanly{@(to_string(f)) MHz}.scale(0.6), p).refocus(p)
    let p:
      stack(~sep: 32,
            cable,
            stack(
              stack(freq("30.5", slots(up,
                                       { 1: c4, 6: c2, 7: c2 },
                                       { 4: t("!").colorize(c3) } ++ (if options[#'collide]
                                                                      | { 14: beside(t("!").colorize(c1),
                                                                                     t("!").colorize(c2),
                                                                                     collide_pip) }
                                                                      | {}))),
                    freq("31.7", slots(up,
                                       { 1: c4, 2: c4, 5: c1, 6: c1, 7: c1, 8: c3, 10: c3 },
                                       { 4: t("!").colorize(c2) }))),
              stack(freq("705.0", packets(down, [[c4, 1], [c1, 2], [c2, 1], [c3, 1]])),
                    freq("711.0", packets(down, [[c2, 1], [c1, 0.75], [sched(c2, c3), 0.25], [c2, 2], [#false, 1]])),
                    freq("717.0", packets(down, [[sched(c4, c4, c1), 0.25], [#false, 1.25], [c4, 3.5]])),
                    freq("723.0", packets(down, [[c3, 2], [c4, 2], [c1, 1]])))
            ).ghost(!options[#'bands]))
    values(p.refocus(cable), p.height - cable.height)
  let cmts = stack(CMTS, server).refocus(server)
  let p = stack(~horiz: #'right, p, beside(cmts, cable).refocus(cable))  
  p.pad(~bottom: pad_amt)

fun docsis_slide(options :~ OptMap, note = #false) :~ OptMap:
  slide(
    ~title: "DOCSIS Cable Internet Protocol",
    block:
      let p = cable(options)
      let p:
        if note == #'cmts
        | balloon.pin(lines(@defterm{Cable modem},
                            @defterm{termination system},
                            @defterm{(CMTS)},
                            @para{is in control}),
                      ~on: p,
                      ~at: Find.left(CMTS),
                      ~spike: #'e)
        | p
      let p:
        if note == #'bands
        | beside(~sep: 100,
                 p,
                 lines(@para{Shared line is split into},
                       @para{channels by frequency},
                       blank(10),
                       beside.topline(@para{—},
                                      @t{ },
                                      @lines(@para{which is an example}
                                             @para{of FDM}))))
            .refocus(p)
        | p
      let p:
        if note == #'more_dl
        | beside(~sep: 100,
                 p,
                 lines(@para{More download channels},
                       @para{than upload channels}))
            .refocus(p)
        | p
      let p:
        if note == #'shared_dl
        | beside(~sep: 100,
                 p,
                 lines(@para{All modems see all},
                       @para{download channels},
                       blank(30),
                       @para{Since only CMTS writes,},
                       @para{no need for slots or},
                       @para{collision handling}))
            .refocus(p)
        | p
      let p:
        if note == #'shared_ul
        | beside(~sep: 100,
                 p,
                 lines(@para{Shared upload channel},
                       @para{has slots},
                       blank(30),
                       lines(@para{Periodic polling uses},
                             @para{ designated slots}).colorize("blue").ghost(!options[#'reqs]),
                       blank(30),
                       lines(@para{Slots are allocated},
                             @para{by CMTS}).ghost(!options[#'sched]))) 
            .refocus(p)
        | p
      let p:
        if note == #'shared_ul && options[#'polling_ok]
        | balloon.pin(lines(@para{Centralized polling},
                            @para{ok, since CMTS},
                            @para{must always work}),
                      ~on: p,
                      ~at: Find.left(CMTS),
                      ~spike: #'e)
        | p
      let p:
        if note == #'collide
        | balloon.pin(lines(@para{Requests may collide,},
                            @para{detected by not},
                            @para{getting an upload slot}),
                      ~on: p,
                      ~at: Find.right(collide_pip),
                      ~dx: -40,
                      ~spike: #'w)
        | p
      let p:
        if note == #'collide && options[#'retry]
        | beside(~sep: 100,
                 p,
                 lines(@tt{ },
                       @tt{ },
                       @para{Collision handled},
                       @para{by random delay},
                       @para{and then retry}).colorize("blue"))
            .refocus(p)
        | p
      p
  )
  options

let options = docsis_slide({})
let options = docsis_slide(options, #'cmts)
let options = docsis_slide(options ++ { #'bands }, #'bands)
let options = docsis_slide(options, #'more_dl)
let options = docsis_slide(options ++ { #'colors, #'download }, #'shared_dl)
let options = docsis_slide(options ++ { #'upload }, #'shared_ul)
let options = docsis_slide(options ++ { #'sched }, #'shared_ul)
let options = docsis_slide(options ++ { #'reqs }, #'shared_ul)
let options = docsis_slide(options ++ { #'reqs, #'polling_ok }, #'shared_ul)
let options = docsis_slide(options ++ { #'collide }, #'collide)
let options = docsis_slide(options ++ { #'retry }, #'collide)

slide(~title: "Summary",
      slide.align(
        ~sep: slide.gap * 2,
        @para{@defterm{Cyclic-redundancy check (CRC)} commonly used at link layer},
        @para{Link-to-physical transition often involves negotiating a shared medium},
        stack.left(
          ~sep: 10,
          @para{Two ways to share:},
          @item{@defterm{Time-division multiplexing (TDM)}}.pad(~left: 30),
          @item{@defterm{Frequency-division multiplexing (FDM)}}.pad(~left: 30)
        ),
        stack.left(
          ~sep: 10,
          @para{Three ways to allocate a division:},
          @item{@defterm{polling}}.pad(~left: 30),
          @item{@defterm{token-passing}}.pad(~left: 30),
          @item{@defterm{random access}}.pad(~left: 30),
          @para{... with @defterm{carrier sense} and/or collision detection}.pad(~left: 80)
        )        
      ))

all_layers_slides(~title: @titlely{Layers — @italic{Done!}},
                  ~crc: #false,
                  ~steps: #false,
                  ~highlight: #false,
                  ~show_why: #true)
